Chapter 4. JPA 시작
===
목차
---
* 영속성 컨텍스트란
  * ACID 원칙
  * commit과 flush의 차이
* 지연 로딩과 즉시 로딩의 차이
* N+1 문제란
* JPQL이란
* QueryDSL이란
  
영속성 컨텍스트란
---
영속성 컨텍스트는 실제 데이터베이스와 백엔드 환경에서 엔티티를 다루는 패러다임의 불일치를 해결하기 위해 도입된 JPA에서 활용하는 일종의 1차 캐시입니다.  
  
영속성 컨텍스트의 기능으로는 다음과 같은 기능들이 존재하는데,
1. 1차 캐시 : 같은 트랜젝션 내에서는 동일한 엔티티들 반복 조회해도 같은 인스턴스를 반환하게 하는 기능
2. 더티 체킹 : 엔티티 필드 값이 바뀌면 JPA가 이를 자동 감지해 트랜젝션 커밋 시점에 UPDATE 쿼리를 수행하는 기능
3. 쓰기 지연 : SQL을 직접 수행하지 않고, 트랜젝션이 커밋되는 시점에 한꺼번에 수행하는 기능
4. 플러시 : 영속성 컨텍스트의 변경 사항을 데이터베이스와 동기화하는 기능

영속성 컨텍스트는 다음과 같은 역할을 수행하게 된다.  
  
### ACID 원칙
데이터베이스의 변경은 하나의 '트랜젝션'을 통해서 변경하게 된다. 이 트랜젝션 단위로 실제 디스크를 변경하고 수행하기 때문에 이에 대한 내용을 다루는 원칙이 있다.

위 내용이 도대체 어떤 이점을 가지는지 알고 싶다면 ACID 원칙에 대해서 이야기를 하지 않을 수가 없다. 데이터베이스의 트랜젝션을 이해해야 JPA가 가지는 이점에 대해서 이해할 수 있다. ACID는 4가지 원칙의 첫 알파벳을 가져와 이어 놓은것으로 내용은 다음과 같다.  
  
#### 1. Atomicliy(원자성)

> 하나의 트랜젝션 내의 모든 작업은 전부 수행되거나 전부 수행되지 않아야 한다.
  
하나의 트랜젝션은 여러 개의 변경 작업으로 구성되어 있다. 예를 들어, 계좌 이체라는 트랜젝션을 실행한다고 할때 실제 데이터베이스의 로직은 다음과 같이 작동하게 된다.  
1. 송금자의 계좌 금액 감소
2. 피송금자의 계좌 금액 증가
이 둘중 하나라도 실패하게 된다면, 송금이라는 행위는 정의되지 않으며, 데이터베이스 내의 데이터에 이상이 생길 것이다. 따라서 이 둘은 하나의 '트랜젝션'으로 처리되어야 하고 위 두개의 독립적인 행위는 하나의 행위로서 정의되어 위 행위중 하나라도 실패하면 언제든 롤백할 수 있어야 한다.  
  
즉, 하나의 트랜젝션이 끝날때 까지의 내용은 언제든 롤백이 가능해야 한다.

#### 2. Consistency (일관성)

> 트랜젝션 전후로 데이터의 제약조건이 항상 만족되어야 한다.
  
위 내용은 데이터베이스가 정의한 무결성 제약 조건을 지켜야 한다는 뜻으로 위의 송금 예시를 다시 들어서 설명하겠다.

1. 송금자의 계좌에는 100달러, 피 송금자의 계좌에는 200 달러가 존재한다.
2. 송금자와 피 송금자의 계좌 총액은 300이고 이를 초과하면 안된다.
3. 송금자가 피 송금자에게 50원을 송금하는 하나의 트랜젝션을 진행한다.
4. 송금자의 계좌에는 50달러, 피송금자의 계좌에는 250 달러가 존재한다.
5. 송금자와 피송금자의 계좌 총액은 300으로 변함이 없다.

즉, '송금'이라는 행위는 금액의 총량을 변경시키면 안된다는 데이터베이스의 제약 조건을 3번 과정인 실제 트랜젝션을 진행한 후에도 변경이 없다. 따라서 일관성이 유지되었다고 볼 수 있고 트랜젝션은 이 규칙을 지켜야 한다.  
  
#### 3. Isolation (격리성)

> 동시에 실행되는 트랜젝션은 서로에게 영향을 주지 않아야 한다.
  
위 내용은 병렬 프로그래밍의 문제와 거의 정확히 일치한다. 여러개의 트랜젝션은 같은 테이블 항목, 로직을 건드리는 경우가 많은데, 이때 이들간의 행위가 각각 독립적인 행위로 취급되어야 하므로 데이터를 읽고 처리하는 과정에서 이를 보장해야 한다.  
  
따라서 상황에 맞는 격리 수준을 채택하여 각각의 데이터 정합성을 보장해야 한다는 이야기이다.  
  
#### 4. Durability (지속성)

> 트랜젝션이 커밋되면 그 결과는 영구적으로 반영된다.

트랜젝션이 커밋이 되는 순간에 하나의 트랜젝션이 드디어 종료되고 그 행위가 디스크에 기록되게 되는데, 그 행위를 로그로 남기는 등의 행위를 함으로서 복구가 가능해지는 지속성을 가져야 한다는 이야기이다.  
  
조금 긴 설명이었는데, 즉, 하나의 '트랜젝션'이 존재하고 이 트랜젝션 내에서는 각 행위는 flush로 기록되고 트랜젝션이 종료되어야 실제 디스크에 영구적으로 기록이 되는 '행위'에 대한 캐싱을 제공한다는 내용을 이해하기 위한 설명이었다.

### commit과 flush
드디어 JPA 내에서 우리는 이 둘의 차이를 이해함으로서 영속성 컨텍스트가 정확히 어떤 일을 하는지 이야기 할 수 있게 되었다.  
  
JPA는 이전에 이야기하였듯이, 엔티티의 변경 사항을 추적한다, 그 변경 사항을 확인하고, flush를 해야 할 상황을 자동으로 판단하여 진행해주고 트랜젝션이 종료되면 트랜젝션을 커밋하는 행위를 자동으로 보장해주는 것이다.

### 지연 로딩과 즉시 로딩의 차이
지연 로딩과 즉시 로딩 lazy 로딩과 eager 로딩에 대해서 조금 이야기 해 보고자 한다, 이 둘은 뒤에서 설명할, N+1 문제의 직접적인 원인이 되는 사항으로 조금 유의해서 볼 필요가 있다.  
  
보통 fetchtype.~ 형식으로 지연 로딩과 즉시 로딩 여부를 진행하게 되는데, 다른 엔티티를 참조하는 참조자 변수 필드에 달아주게 된다. 

#### 즉시 로딩
어떤 엔티티가 참조하는 다른 연관 엔티티들도 전부 끌고와서 객체화 시킨다.

#### 지연 로딩
어떤 엔티티가 참조하는 다른 연관 엔티티의 아이디 값만 가져와서 필요 시에만 id 값으로 조회한다.

### N+1 문제
즉시 로딩을 진행하면 어떤 한 엔티티를 호출하는 순간 그 엔티티는 물론이고, 그 엔티티가 참조하는 다른 엔티티들을 전부 끌고오게 된다. 위 전략은 미리 다른 엔티티들을 객체화 시켜놓음으로서 jpa의 장점인 캐싱을 잘 활용하는것 같지만 다음과 같은 상황에서는 문제가 발생하게 된다.

> 나는 어떤 유저의 정보를 보고 싶다. 그래서 유저.~ 과 같이 접근하여 로직을 수행한다. 그러나 유저는 즉시 로딩 전략이 걸려있는 게시글을 참조하는 참조자가 달려 있고, 유저가 작성한 게시글은 약 100개 정도가 된다.

즉시 로딩을 채택하면 나는 유저 정보만 가져왔는데, 100개의 게시글을 가져오게 된다. 여기까지는 문제가 없다. 그런데 다음과 같은 상황을 가정해보자,

> 나는 여러 유저들의 정보를 보고 싶다.

이때 바로 우리가 흔히 말하는 N+1 문제가 발생하며 이것이 바로 즉시 로딩을 개발에서 지양해야 하는 이유이다.
유저를 100명 조회를 할 때 즉시 로딩을 하는 순간, 유저 100명의 게시글을 전부 끌고오게 된다. 내가 조회하고 싶은 것은 유저의 리스트만 조회하고 싶지만 방대한 양의 게시글까지 객체화 되어서 끌려오게 되며, 그것을 위해서 게시글을 끌고오는 N개의 쿼리가 추가로 발생하게 된다. 하나의 쿼리만 날아가서 유저만 끌고오면 될 것을 각 유저별로 게시글을 끌고오는 쿼리를 유저수만큼 반복하므로 트래픽을 쓸데없이 증가시키게 된다.  
  
따라서 실제 개발시에는 Lazy 로딩 전략을 채택하고 필요시에 추가로 끌고 오게 하는 전략을 채택하게 하는 것이 좋다.

### JPQL
SQL은 데이터베이스에 적용해서 사용이 가능한 쿼리 문법이다, 즉 데이터베이스 안의 테이블 항목과 컬럼들을 선택하고 처리하는 언어인 것이다.  
JPA는 정말 많은 것을 자동화시켜주지만 잘못 설계하면 비효율적인 쿼리를 날려버릴 수 있는데, 이때 JPQL로 자바 내의 '엔티티'를 직접 조작하여 다룬다.  
  
즉 JPQL은 자바의 엔티티를 조작하는 쿼리 언어로서 실제 SQL 문법과 거의 매우 유사한 문법으로 데이터베이스 로직을 작성이 가능하다.
  
쿼리를 직접 작성해야 하는 상황이라면 언제든 사용이 가능하다.
  
JPQL은 다음과 같은 두가지의 사용 방법이 존재한다.
1. @Query 어노테이션으로 jpql 문법을 직접 작성하고 해당 엔티티의 요소와 쿼리문 내의 요소를 매칭
  
ex)
``` java
@Query("select p from Post p join p.author a where a.name = :name")
    List<Post> findByAuthorName(@Param("name") String name);
```
  
2. 레파지토리 인터페이스 내에서 쿼리 메소드 작성
  
ex)
``` java
List<Post> findByAuthor_NameAndStatusOrderByIdDesc(String name, Status status);
```
  
### QueryDSL
위의 jpql은 jpa에 종속적인 기능이라면 QueryDSL은 쿼리의 각 구문 자체를 메서드 체이닝 형식으로 이어서 생산하여 직접 쿼리를 생성하는 Query 생성 라이브러리이다.

당연히 메서드 빌더 형식으로 구성되어 있으므로 타입 안전성 체크가 가능하고, 컴파일 타임에 문제 체킹이 가능하다는 장점이 있다.

### 미션
[5주차 미션](https://github.com/hexter31376/umc_mission4/branches)

### 후기
jpa의 구조를 좀 더 자세히 알아감과 동시에 덤으로 ACID 원칙에 대해 짚어감으로서 jpa가 하는 역할과 그 장점에 대해 좀 더 자세히 알아가는 기회가 된 것 같고, jpa가 쿼리의 커스터마이징도 어느정도 지원한다는 것을 알게 되었습니다...