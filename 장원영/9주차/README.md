Chapter 9. 페이징 API 설계
===
목차
---
* 페이징이 필요한 이유
* 페이징 요청/응답 DTO 설계
* API 페이지 구성 흐름
* Swagger 기반 문서화
* 계층형 구조
  * 컨트롤러
  * 서비스
  * 레파지토리
  * DTO와 엔티티
* 최종 프로젝트 세팅
  
페이징 API 설계
---
### 페이징이 필요한 이유
이번 스터디의 목표는 `페이징 dto를 구성한다`, `api 페이지를 구성한다`는 두 가지 요구를 만족하는 백엔드 설계안을 도출하는 것이었습니다. 사용자 수가 증가하면서 데이터 조회 요청 역시 증가하므로, 한 번의 호출에 전체 데이터를 반환하는 방식은 메모리 낭비, 전송량 증가, 응답 지연으로 이어집니다. 페이징은 이러한 문제를 해결하여 클라이언트가 필요한 구간만 요청하도록 하고, 서버는 계산된 범위의 데이터와 전체 통계를 함께 전달하면서 API의 신뢰성과 사용자 경험을 높입니다.  
  
### 페이징 요청/응답 DTO 설계
페이징 Request DTO는 클라이언트가 원하는 페이지, 사이즈, 정렬 기준을 명시할 수 있도록 `page`, `size`, `sort`, `direction` 필드로 단순화합니다. 기본값을 0페이지, 20건으로 두면 대부분의 목록 API에 재사용할 수 있고, 허용 가능한 최대 사이즈 상한을 두어 과도한 조회를 방지합니다.  
  
Response DTO는 단순히 `List<T>`를 전달하는 대신 `content`, `page`, `size`, `totalElements`, `totalPages`, `hasNext`, `hasPrevious` 같은 필드를 포함하도록 설계합니다. 이렇게 하면 프론트가 추가 API 호출 없이 페이지 네비게이션을 그릴 수 있고, 테스트에서도 총 건수와 현재 페이지를 기준으로 페이징 계산이 맞는지 검증 가능합니다. 필요한 경우 `sortInfo`, `searchCriteria` 같은 메타데이터를 포함하여 특정 조건으로 조회한 결과임을 명확히 표현합니다.  
  
### API 페이지 구성 흐름
페이징 API는 `/v1/books?page=0&size=10&sort=createdAt,desc`처럼 RESTful 쿼리 파라미터를 사용합니다. 컨트롤러는 Request DTO를 통해 입력을 검증하고, 서비스 계층으로 `Pageable` 혹은 커스텀 커서 객체를 전달합니다. 서비스는 조건에 맞는 엔티티를 조회하고 Response DTO로 변환하여 계층 간 의존성을 최소화합니다.  
  
API 스펙에는 성공/실패 응답 예시를 명시합니다. 예를 들어 성공 시 `content` 배열과 함께 `pageInfo` 객체에 통계 값을 넣고, 비어 있는 페이지를 요청했을 때는 빈 배열과 `hasNext=false`를 반환하여 클라이언트가 예외 없이 처리하게 합니다. 또한 필터링 조건(카테고리, 검색어 등)을 Request DTO에 포함시키되, 페이징 관련 필드는 일관된 네이밍을 유지하여 여러 API가 동일한 DTO를 공유하도록 합니다.  
  
### Swagger 기반 문서화
Swagger를 통해 페이징 Request/Response DTO의 필드 설명을 명확히 남깁니다. `@Schema`와 `@Parameter`를 사용해 페이지 기본값, 허용 범위, 정렬 방식에 대한 문장을 작성하면 프론트 개발자가 문서를 통해 그대로 사용할 수 있습니다.  
  
또한 Swagger 문서에서 example 값을 실제 예상 데이터로 채워두면, 페이징이 어떻게 동작하는지 시각적으로 검증할 수 있습니다. `PageResponse<BookSummary>`처럼 제네릭 타입을 사용하는 경우 모델명이 난해해질 수 있으므로 명시적으로 DTO를 만들어 노출하거나 `@Schema(name="BookPageResponse")`로 가독성을 확보합니다. 이러한 문서화를 통해 API 페이지 구성 과정이 개발자와 기획자 모두에게 투명하게 공유됩니다.  
  
### 계층형 구조
페이징 기능 역시 계층형 구조를 따르면서 책임을 나누면 확장성이 좋아집니다.
  
#### 컨트롤러
HTTP 입출력을 담당하는 컨트롤러는 `PagingRequestDto`를 `@Valid`로 검증하고, 잘못된 파라미터는 400 응답으로 조기에 차단합니다. 또한 Swagger에서 정의한 예시를 기반으로 성공/실패 응답을 문서화하여 API 페이지 개념을 그대로 REST 엔드포인트로 연결합니다.  
  
#### 서비스
서비스는 요청된 페이지 기준으로 핵심 비즈니스 로직을 수행합니다. 검색 조건을 조립하고, Repository에서 받아온 `Page<Entity>`를 `PageResponseDto`로 변환합니다. 이곳에서 추가로 필요한 통계를 가공하거나, 페이징을 위한 캐시 전략을 적용해 반복 호출 시 낭비를 줄입니다.  
  
#### 레파지토리
레파지토리는 JPA의 `Pageable`을 그대로 사용하거나, 커서 기반 페이징을 위해 QueryDSL/네이티브 쿼리를 작성합니다. 정렬 키에 인덱스를 맞추고, 조인 시에도 페이징이 깨지지 않도록 `countQuery`를 최적화하는 것이 핵심입니다. 만약 다중 정렬을 지원해야 한다면 DTO에서 전달받은 정렬 정보를 동적으로 해석하여 `Sort` 객체를 생성합니다.  
  
#### DTO와 엔티티
엔티티는 데이터 정합성 규칙을 유지하고, DTO는 외부 노출 전용 뷰 역할을 합니다. Response DTO에서만 필요한 필드는 정적 팩터리나 Mapper를 통해 채워 넣어 컨트롤러가 엔티티에 직접 접근하지 않도록 합니다. Validation과 직렬화 규칙을 DTO에 모아두면 계층 간 의존이 줄고, 페이징 공통 모듈화도 쉬워집니다.  
  
### 최종 프로젝트 세팅
9주차 미션에서는 기존 코드 베이스에 페이징 공통 모듈을 도입할 계획입니다.  
[9주차 미션](https://github.com/hexter31376/umc_mission4/tree/study/Chapter7)
  
1. 도메인별 조회 API에서 Request/Response DTO를 공통화하여 스터디 주제인 페이징 DTO 구성을 코드로 옮깁니다.
2. 스웨거 설정에 example과 제약 조건을 추가해 API 페이지 구성을 문서화하고, QA 팀이 바로 확인할 수 있도록 합니다.
  
### 후기
Response DTO 페이징 모델과 Swagger 문서화를 함께 정리하면서, API가 사용자에게 어떻게 보이는지까지 고려한 설계가 필요함을 다시 느꼈습니다. 프로젝트에 적용하면 데이터 양과 무관하게 일정한 응답을 보장할 수 있을 것 같아 기대됩니다. 다음 미션에서는 정렬, 필터링, 캐싱 전략까지 확장해보며 완성도를 높이고 싶습니다.  
