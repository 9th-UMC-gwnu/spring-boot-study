Chapter 2. 스프링부트의 코어 개념
===
목차
---
* 프레임워크 vs 라이브러리 그리고 api
* DI와 IOC
* 서블릿
* 의존성 주입 방식
  
프레임워크 vs 라이브러리 그리고 api
---
### 프레임워크란
프레임워크란 말 그대로 틀을 제공하는 것으로, 여기서 말하는 프레임워크는 어플리케이션의 전체적인 구조와 실행 흐름을 제어하는 틀입니다. 개발자가 프레임워크에서 정의한 사용법 정의에 따라 코드를 작성하며, 프로그램의 주도권을 프레임워크가 가지게 됩니다.  
즉, 프로그래머는 프레임워크에서 정의한 문법에 따라 작성하여 프레임워크가 만들어주는 틀을 커스텀하는 방식으로 개발을 진행하게 됩니다.
### 라이브러리란
라이브러리란 말 그대로 개발자가 원하는 기능을 구현해놓은 일종의 도구 역할을 하는 코드 뭉치로서, 이 라이브러리의 기능을 프로그래머가 원하는대로 이리저리 끼워넣어 사용합니다. 이때 코드의 흐름은 개발자가 직접 제어하고 라이브러리는 이에 관여하지 않습니다.
### 비교표
| 구분 | 프레임워크 | 라이브러리 |
| --- | ------- | ------- |
| 제어 권한 | 프레임워크가 흐름 제어 (IOC) | 개발자가 직접 호출 및 관리 |
| 구조 | 아키텍처와 규칙 제공 | 기능만 제공, 사용하는것은 개발자의 자유 |
| 사용 방식 | 코드 자체가 프레임워크에 종속됨 | 코드가 라이브러리를 호출함 |
| 예시 | Spring | stdio.h, stdlib.c |
### API
API는 어플리케이션 프로그래밍 인터페이스의 줄임말로서 라이브러리나 프레임워크, 각종 프로그래밍 코드에서 접근하는 통로입니다. API는 절대로 라이브러리나 프레임워크 같은 툴이 아니며, 어떠한 기능을 호출하기 위해서 약속된 규격입니다.  
    
예를 들어 가장 유명하게 들어봤을법한 REST API를 살펴보겠습니다. http 통신에서 get, post, put, patch, delete 다섯가지 메소드 중 하나와 그 요청을 처리할 엔트포인트 {서버주소}/{엔트포인트} 형식으로 요청하는 순간 메소드에 따라 적절한 엔드포인트와 적절한 CRUD를 진행하겠다라는 '약속'입니다. 이는 언어나 프레임워크, 라이브러리 등 어디에도 종속되지 않으며 해당 규칙을 채택한 사람들끼리 유효한 일종의 프로토콜 같은 것입니다. 이는 구현체들간의 최종 통신 방식을 어떻게 진행하겠다란 약속으로 볼 수 있게 됩니다.
  
DI와 IOC
---
### 의존성 주입
의존성 주입 (Dependency Injection)은 스프링이라는 프레임워크에서 아래에서 설명할 제어의 역전을 구현하기 위한 아주 중요한 요소 중 하나입니다.  
기본적인 정의부터 설명하자면 객체가 직접 의존성을 생성하지 않고 외부에서 주입받는다는 개념인데, 객체 간의 '결합도'를 낮추는데에 그 핵심이 있습니다.

``` java
class Namelist {
    private ArrayList<String> name = new ArrayList<String>();

    // ... 기타 메소드 ... //
}
```


다음과 같은 코드를 보면 어떤 클래스가 다른 클래스를 필드로 가지고 있으면서 동시에 자기 자신이 그 필드를 생성하여 초기화하고 있습니다. 이러한 문법은 평소에는 문제가 되지 않지만 다음과 같은 상황에서는 문제가 됩니다.
1. 더이상 shop 객체가 pen이 아닌 다른 물건을 팔아야 할 때
2. 다른 물건들 또한 받아들여야만 할 때

1번 케이스의 경우 기존의 shop 클래스 코드에서 pen 생성부를 다른 클래스로 교체하고 그에 따른 메소드들을 전부 수정해 주어야 하고, 
2번 케이스의 경우도 필드의 추가로 해결할 수 있지만 역시 그것이 요구하는 다른 메서드들을 구현해야만 할 것입니다.  
이러한 상황은 해당 객체가 의존하는 의존 객체의 형태가 바뀌거나 새로운 것을 작성해야 할 때 그 의존성을 사용하는 코드에 대한 수정도 필요해지게 되는데 이것은 개발 생산성을 매우 떨어뜨리게 됩니다.  
  
그래서 고안된 방식이 바로 의존성 주입이며, 이것이 스프링의 핵심이라고 봐도 무방하겠습니다.

그래서 의존성 주입을 실제로 어떻게 사용하는지를 확인해보자면,

``` java
class Namelist {
    private List<String> name;

    NameList (List<String> name) {
        this.name = name;
    }
}
```

이런 식입니다. 보이는 바와 같이 해당 클래스 내에서 절대로 객체를 생성하지 않으며 지금 상황의 경우에는 생성자를 통해 해당 List 인터페이스형 필드를 List 인터페이스를 implement한 어떤 구현체(ArrayList, LinkedList 등등)든지 간에 받아 들일 수 있게 됩니다.  
  
즉, 객체 자체를 의존하는것이 아닌 그 객체의 인터페이스에 의존함으로서 그 구현체가 자기 자신이 요구하는 '규격'에만 맞는다면 자기 자신을 수정할 필요 없이 다른 의존성들을 유연하게 받아들일 수 있는 개념이 바로 이 의존성 주입인 것입니다.  
  
그렇다면 생성을 외부에서 받는 것은 이해가 되는데, 이걸 언제 생성하고 언제 집어넣냐구요? 그것을 다음에 설명할 예정입니다.
### 제어의 역전
바로 제어의 역전이 이 내용을 설명하는 부분입니다. 스프링에서는 이 의존성 주입 틀에 따라 객체를 '언제' 집어넣을 것인지를 결정하게 되는데 이 생성을 개발자가 하는 것이 아닌 스프링 프레임워크가 하도록 하는 것이 바로 제어의 역전입니다.

이를 통해 스프링에서 프레임워크의 틀에 따라 구현된 다양한 자동화 기능들을 통해 객체의 생성 주기를 신경 쓸 필요 없이 구현이 가능해지며, 개발 시에 기능을 확장할 때에도 보다 유지보수에 최적화된 방법으로 확장이 가능해지게 되는 것입니다.


서블릿
---
### 서블릿이란?
서블릿이라는 단어는 자바 진영에서 나온 개념으로서, 자바 기반의 웹 어플리케이션에서 http 요청과 응답을 처리하는 서버 측 컴포넌트를 의미합니다.  
웹과 자바는 그 환경이 다르고 데이터의 통신 방법 또한 다른데, 해당 데이터를 http 요청을 통해 적절한 포맷으로 떨궈주는 프로그램인 것입니다.
옛날 어르신 시절 코딩때는 실제로 이 서블릿을 통해 html 코드 등을 떨궈주는 식으로 웹 페이지를 구성하였습니다.
### 스프링의 서블릿
그러나 지금 우리는 html을 통째로 떨궈주는 무식한 개발을 하진 않습니다. 우리는 이미 프론트엔드와 백엔드라는 단어로, 정적 리소스, 클라이언트부와, 데이터 통신, 서버부로 나누었고, 서블릿은 그에 맞게 새로운 데이터 포맷인 json포맷을 rest API를 통해 떨궈주게 되었습니다.

그에 따라 다양한 rest API 에 맞는 엔드포인트와, 그 엔드포인트에 맞는 crud를 진행하여야만 했는데, 스프링에선 POM.xml을 통해 엔드포인트와 컨트롤러를 매칭시키는 방식으로 서블릿 통신을 진행하였습니다.
하지만 스프링에서 디스패처 서블릿이라는 것이 등장하였고 POM.xml 작성 없이 디스패처 서블릿이 url을 분석하고 스프링 코드 레벨에서 어노테이션을 통한 적절한 매핑이 진행된 컨트롤러가 해당 서블릿 통신을 진행할 수 있도록 그 기반을 마련하게 된 것입니다.
  
스프링 사용 객체 등록
---
### Bean과 Autowired
아까도 설명하였듯이, 제어의 역전을 통해 객체의 생명주기를 관리하기에 프로그래머가 직접 객체를 생성하는것 자체를 막아놓았습니다. 따라서 객체를 직접 생성하는 것이 아닌 어떤 객체를 만들어서 넣어주고 싶다면 스프링에서 인식 가능한 객체 풀을 만들어 주어야 하는데 이때 여기에 들어가는 Bean이라는 개념이 있습니다. 이 빈은 스프링에서 인식 가능한 일종의 객체 풀이며, 메소드에 붙여서 사용하게 됩니다.  해당 메소드는 빈으로 등록하고자 하는 객체를 리턴하는 방식으로 구현합니다.

그리고 이 객체를 사용하려면 Autwired 어노테이션을 통해 스프링이 알아서 찾아서 넣어주게 하는 것이 가능합니다.
  
### Component
빈으로 주입하는 방식은 가장 기초적이지만 보일러플레이트 코드를 너무 많이 발생시킵니다. 컨피규레이션 클래스를 만들고 거기에 등록을 해 주기 때문인데, 클래스의 구성과 등록을 간편하게 하기 위해 등록하고자 하는 클래스의 위에 컴포넌트 어노테이션을 작성해주면 그 클래스 자체의 생성과 주입을 자동으로 처리해주게 됩니다. 향후 배우게 될 스프링 웹의 컨트롤러, 서비스, 레파지토리, 엔티티 등의 모든 어노테이션이 이 컴포넌트를 기반으로 이루어져 있어 어노테이션만 작성하면 해당 요소의 기능을 프레임워크 틀에 맞추어 간편하게 구현이 가능해집니다.
