# 🌱JPA 기초 활용

# Spring Data JPA 영속성 컨텍스트
## 영속성 컨텍스트란?
- 영속성 컨텍스트는 엔티티를 영구 저장하는 환경이라는 뜻이다.
- 애플리케이션고 데이터베이스 사이에서 객체를 보관하는 가상의 데이터베이스 같은 역할을  한다.
- 일종의 캐시 메모리라고 생각하면 된다.
- 엔티티 매니저(EntityManager)로 엔티티를 저장하거나 조회하면 엔티티 매니저는 영속성 컨텍스트에 엔티티를 보관하고 관리할 수 있게 된다.

---
## 영속성
- 애플리케이션 단의 객체를 엔티티 매니저가 계속 관리를 하면서, 변경 내용을 추적하는데 이때 엔티티 매니저가 관리한다는 개념이 영속성이다.
- 객체의 생명주기는 다음과 같이 분리된다.
  ```
  비영속성
  - 엔티티 객체를 단순히 생선한 상태
  
  영속성
  - 엔티티 매니저를 통해 엔티티를 영속성 컨텍스트에 저장하거나, DB로 부터 조회하였을 떄 영속성 컨텍스트가 엔티티를 관리.
  
  준영속성
  - 영속성 컨텍스트가 관리하던 영속 상태의 엔티티를 영속성 컨텍스트가 관리하지 않게 됐을 때 준영속 상태
  
  삭제
  - 엔티티를 영속성 컨텍스트와 데이터베이스에서(flush() 호출 시) 삭제한다.
  ```
- #### 영속 상태의 장점
    ```
  1차 캐시
  영속성 컨텍스트는 공식 문서에서 데이터베이스와 상호작용하는 1차 캐시 역할을 한다
  엔티티를 한번 조회하여 영속성 컨텍스트 안에 저장되어 트랜잭션이 끝날 떄까지 캐시처럼 유지된다.
  
  EntityManager의 변경 감지
  관리되는 엔티티가 수정된 것으로 표시되어 있다면, 플러시 과정에서 UPDATE SQL이 자동으로 생성된다.
  이 과정에서 더티 채킹 메커니즘은 엔티티가 처음 로드된 이후로 변경되었는지 여부를 판단하는 역할을 한다.
  
  지연 로딩
  지연 로딩은 DB가 아닌 프록시에서 데이터를 가져온다.
  조회할 객체만 조회, 나머지 연관된 객체들은 모두 프록시로 처리
    ```
- ### N+1 문제
  - RDB와 객체 지향의 패러다임 간극에 의해 발생하는 문제이다.
  - 1개의 쿼리가 실행되면 관련된 N개의 데이터를 가져오기 위해 추가적으로 N번의 불필요한 퀴리가 실행됨
  - 이걸 해결하기 위해 지연 로딩을 통해서 불필요한 데이터를 가져오는 것을 막음

---
# JPQL
- JPA의 일부로, 쿼리를 데이터베이스의 테이블이 아닌 JPA 엔티티, 즉 '객체'를 대상으로 작성하는 객체 지향 쿼리 언어
- JPQL에서는 SQL문과 형태가 비슷하지만 '테이블과 컬럼'을 대상으로 하는 것이 아닌 '엔티티와 변수'를 대상으로 쿼리를 작성
- 자바의 특성을 최대한 활용할 수 있고, 쿼리 결과를 객체 또는 객체의 컬렉션으로 직접 변환받을 수 있다.
- 실행하는 법
  - 메서드 이름으로 쿼리 생성
  - @Query 어노테이션
---
## Spring Data JPA
- JPA가 제공하는 JPQL을 활용하여 객체 모델을 SQL로 변환할 수 있도록 도롸준다.
- 메서드 이름을 엔티티의 컬럼과 규칙에 맞게 작성하면, Spring Data JPA가 메서드 이름을 해석하여 쿼리를 자동으로 생성

## QueryDSL
- 타입 안전성을 보장하는 자바 기반의 쿼리 빌더 라이브러리
- 타입-세이프하게 쿼리를 작성하고록 지원하며 SQL 형태가 아닌 '자바 코드'로 작성하여 데이터베이스 쿼리 작성을 쉽고 안전하게 만들어준다.
- 여기서 타입 세이프란 프로그램 언어의 특성을 나타내는 용어로 프로그램이 실행되는 동안 데이터의 타입을 체크하여 타입 오류를 방지하는 것을 의미
- #### 동적쿼리 지원
  - 동적으로 쿼리를 작성하는 것으로 이를 통해 프로그램 실행 중에 조건에 따라 쿼리를 변경
---
# 핵심 키워드
1. ### 지연로딩과 즉시로딩의 차이
- #### 즉시로딩
    - 데이터를 조회할 떄, 연관된 모든 객체의 데이터까지 한 번에 불러오는 것
    - 쿼리를 날려 한꺼번에 데이터를 모두 불러오는 것
- #### 지연로딩
  - 필요한 시점에 연관된 객체의 데이터를 불러오는 것
  - 지연 로딩을 이용하면 맨 처음 조회를 할 때 모든 정보를 가져오는 것이 아닌 필요할 때 요청해서 쿼리가 나갈수 있게한다.
2. #### JPQL
- JPQL은 테이블이 아닌 객체를 대상으로 검색하는 객체지향 쿼리 언어
- JPQL 특징
- | 특징         | 설명                                                                                               |
  |------------|--------------------------------------------------------------------------------------------------|
  | 기본적인 연산 지원 | SELECT, UPDATE, DELETE, INSERT(Embeddable 클래스에 한정) 등의 기본적인 연산을 지원하며, 함수, 연산자, 키워드 등 다양한 기능을 제공한다 |
  | 객체지향 쿼리 언어 | 자바의 특성을 최대한 활용할 수 있으며, 쿼리 결과를 객체 또는 객체의 컬렉션으로 직접 반환받을 수 있다.                                      |
- |타입 안정성 제공| 컴파일 시점에 쿼리의 문법 오류를 검사할 수 있다.                                                                     |
3. #### Fetch Join
- JPQL에서 제공하는 조인의 종류
- 조회의 주체가 되는 ENtity 이외에 Fetch Join이 걸린 연관 Entity도 함께 SELECT 하여 모두 영속화
- Fetch Join이 걸린 Entity는 모두 영속화하기 떄문에 FetchType이 Lazy인 Entity를 참조하더라도 이미 영속성 컨테그슽에 들어 있기 때문에 따로 쿼리가 실행되지 않은 채로 N+1 문제가 해결됨
4. #### @EntityGraph
- Spring Data JPA는 JPA가 제공하는 엔티티 그래프 기능을 편리하게 사용하게 도와주는데, 이 기능이 바로 @EntityGraph이다.
- JPQL로 fetch join을 직접 작성하지 않는 대신 @EntityGraph 어노테이션을 붙임으로서 fetch join을 편리하게 사용할 수 있다.
- 여기서 @EntityGraph는 left outer join만을 지원한다
5. #### commit과 flush 차이점
- flush
  - 영속성 컨텍스트의 변경 내용을 데대아토 베이스에 반영하는 작업
  - SQL 쿼리는 DB로 전송되지만 해당 트랜잭션에 머물러있는 상태이지만 영구적인 저장은 되지 않는 상태
- commit
  - 해당 트랜잭션을 종류하고 변경 사항을 DB에 영구 반영한다.
- commit을 해야만 실제 DB에 반영이 되고 flush만 한다고 실제 DB에 저장되지 않고 SQL을 한번에 저장하기 위해 쓰기 지연을 사용
6. #### QueryDSL, OpenFeign의 QueryDSL
- QueryDSL 라이브러리에는 HQL 인젝션 취약점이 있다. 이것은 JPAQuery의 orderBy 메서드에서 사용자 입력을 적절히 검증하지 않아 발생한다.
- 기존 QueryDSL의 구조적 한계, 그리고 보안 취약점 문제를 해결하기 위해 OpenFeign팀은 기존 QueryDSL 프로잭트를 포크하여 환경과 보안 요구사항을 충족하는 실질적인 대안을 만들어내었다.
7. #### N+1 문제를 해셜할 수 있는 여러 방안들
- Fetch Join + Lazy Loading
  - Fetch Join은 Root Entity에 대해서 조회 할 때 Lazy Loading 으로 설정 되어있는 연관관계를 Join쿼리를 발생시켜 한번에 조회할 수 있는 기능입니다.
- default_batch_fetch_size, @BatchSize
  - Lazy Loading시 프록시 객체를 조회할 때 where in절로 묶어서 한번에 조회 할 수 있게 해주는 옵션입니다.
  - yml에 전역 옵션으로 적용할 수 있고 @BatchSize를 통해 연관관계 BatchSize를 다르게 적용할 수 있습니다.
- @EntityGraph
  - etchJoin을 Annotation방식으로 편리하게 사용하는 기능으로 알고 있었는데 사실은 Lazy Loading을 Eager Loading으로 부분적으로 전환하는 기능입니다.
  - 여러 1:N 연관관계를 한번에 Join해 올 수 있습니다. FetchJoin의 경우 1개의 Collection까지만 같이 Join하여 조회할 수 있습니다.
- 일반 join후 Projection하여 특정 컬럼만 Dto로 조회
  - 장점: Entity Column이 많을 때 Projection하여 특정 컬럼만 조회할 수 있음, 커버링 인덱스 활용가능성 상승.
  - 단점: 영속성 컨텍스트와 무관하게 동작하고 Repository가 Dto에 의존하게 되기 때문에 API변경에 DAO도 수정되어야 할 수 있음.
8. #### 영속 상태의 종류
   1. 비용속 상태
      - 객체만 생성하고 엔티티와 연결이 되지 않는다.
   2. 영속 상태
      - @Id로 매핑된 키값이 있어야한다.
      - 객체를 생성하고 저장한 상태
      - 영속성 컨텍스트가 관리하는 엔티티
   3. 준영속 상태
      - 엔티티가 영속성 컨텍스트에서 분리
   4. 삭제 상태
      - 엔티티 삭제
   - 상태 변화는 비영속->영속->삭제 이거나 영속 -> 준영속 이다.
---

# 학습 후기
- JPQL이 객체지향 SQL느낌을 지원하는 것과 그것을 사용하기 편하게 만들어준다는 것을 알게되었다.
- 여기서 QueryDSL의 검증 로직과 JPQL구문을 합쳐서 사용할 수는 없을까 라는 의문증이 들었다.
- 영속성에 대해서 제대로 알고 사용하여야 데이베이스를 응용할 떄 좀 더 효과적으로 사용할 수 있겠다는 생각이 들었다.
---

# 미션
### 1주차 사진
 <img alt="erd0" src="https://github.com/mybookG/image/blob/main/erd0.png?raw=true" />

### github 링크
https://github.com/mybookG/Umc_personal_repository/tree/main/UMC_4%EC%A3%BC%EC%B0%A8%EB%AF%B8%EC%85%98