# Spring Data JPA 영속성 컨텍스트

- 데이터를 영구적으로 저장할 엔티티 객체를 관리하고, 변경 내용을 추적하는 메모리 상의 논리적 공간
- 최초로 엔티티에 접근 시 DB에서 끌어온 엔티티를 영속성 컨텍스트에 등록하면 이후에 해당 엔티티 접근 시 쿼리를 날리지 않고 가져옴
  -> 일종의 캐시 메모리
  -> EntityManager 통해 접근


## 영속

- 영속성 컨텍스트에서 관리되는 상태를 의미
  - 즉, EntityManager에 의해 관리되는 상태를 의미


## EntityManager 변경 감지(Dirty Checking)

- 관리되는 엔티티가 수정된 것으로 판단되면 플러시 과정에서 UPDATE 쿼리문이 자동 생성
- 개발자가 직접 UPDATE를 호출하지 않아도, 엔티티의 변경 사항을 자동으로 감지하고 데이터베이스에 반영
  -> 매커니즘은 엔티티가 처음 로드되었을때와 비교해서 변경 여부로 판단


## 즉시 로딩(FetchType.EAGER)

- 어떤 한 엔티티를 조회할 때 해당 엔티티와 연관된 모든 엔티티를 조회

## 지연 로딩(FetchType.LAZY)

- 조회할 객체만 조회, 나머지 연관된 엔티티들을 모두 프록시로 처리
  - 필요할 때만 가져오는 구조


### N + 1 문제

- 1개의 쿼리를 실행 후, 이후 관련된 N개의 데이터를 가져올 때 추가로 발생하는 N번의 불필요한 쿼리문이 발생하는 경우
- EX)
  - *즉시 로딩을 채택한 경우* 한 엔티티가 여러 개의 연관 엔티티를 가지고 있을 경우 N + 1 문제가 발생할 수 있음
    - SELECT * FROM member; SELECT * FROM member_food WHERE member_id = ?;
  - *지연 로딩을 채택한 경우* 연관 엔티티를 프록시로 처리하기 때문에 즉시로딩에 비해 성능 최적화 가능
  - *하지만, 지연 로딩도 이후 연관 엔티티를 불러올 경우 N + 1 문제 발생 가능*
    - for (Member m : members) { System.out.println(m.getMemberFoods().size()); }
  - 이럴 경우 *JPQL로 JOIN FETCH를 이용한 메소드를 작성하여 해결 가능*


---


# JPQL

- JPA의 일부로, 쿼리를 데이터베이스의 테이블이 아닌 JPA 엔티티, 즉 ’객체‘를 대상으로 작성하는 객체 지향 쿼리


## 메소드 이름으로 쿼리 생성

- 요구사항에 맞게 이름과 상태를 조건으로 내세운 메소드 이름을 정의하면 자동으로 JPQL 쿼리 생성
  - EX) List<Member> findByNameAndDeletedAtIsNull(String name);
    - 원하는 name 필드와 DeletedAt 필드가 Null 값인 엔티티를 조회
- 메서드 이름만으로 조건, 정렬, 페이징 등을 포함한 쿼리를 자동 생성
- *단, 복잡한 조건이나 동적 쿼리에선 @Query 어노테이션이나 QueryDSL같은 도구가 필요*
- 자동 생선된 쿼리문은 항상 효율적이지 않아 *실행된 쿼리문을 확인하고 분석하는 것이* 중요


## @Query 어노테이션 

- JPQL을 직접 작성하는 방법
- `@Query` 어노테이션을 활용하여 이름과 상태를 조건으로 조회하는 JPQL 쿼리를 작성하고,
- `@Param` 어노테이션을 통해 JPQL 쿼리에서 사용되는 파라미터를 메서드의 인자와 연결
  - EX) @Query("select m from Member m where m.name = :name and m.deleted_at is null")
        List<Member> findActiveMember(@Param("name") String name);
- 추가적으로, nativeQuery = true 파라미터를 통해 JPQL의 쿼리문이 아닌 SQL문을 실행 가능
  - EX) @Query(value = "SELECT * " + "FROM member " +
      "WHERE name = :name AND deleted_at IS NULL", nativeQuery = true)
        List<Member> findActiveMember(@Param("name") String name);
  - 복잡한 쿼리 작성과 실행 속도 최적화가 가능하지만, DB 종속과 영속성 컨텍스트 연동 약화라는 단점


## QueryDSL

- - **타입 안전성을 보장**하는 **자바 기반의 쿼리 빌더 라이브러리** 입니다.
- QueryDSL은 코드 기반의 쿼리 빌더를 제공하기 때문에
- 컴파일 시점에 쿼리의 오류를 잡을 수 있으며 동적 쿼리 작성이 편리하고
- 메서드 체이닝을 통한 복잡한 쿼리 작성에 유리

### 동적 쿼리

- 실행 시점에 쿼리의 일부가 변경될 수 있는 쿼리를 의미
- 요구사항에 따라 쿼리의 조건이 변하거나 구조가 유동적으로 조정되어야 하는 경우 중요

### 메서드 체이닝

- 메서드 호출 후 반환된 객체에서 또 다른 메서드를 연속 호출하는 패턴


# 핵심 키워드 

- **지연로딩과 즉시로딩의 차이**

  - 즉시 로딩 
    - 필요한 엔티티를 가져올 때 연관 엔티티까지 모두 조회하여 가져옴 
  - 지연 로딩
    - 필요한 엔티티를 가져올 때 연관 엔티티까지 조회하지 않고 프록시 상태로 처리
    - 연관 엔티티가 필요할 때 조회


- **JPQL**

  - JPA의 일부로, 쿼리를 데이터베이스의 테이블이 아닌 JPA 엔티티, 즉 ’객체‘를 대상으로 작성하는 객체 지향 쿼리 언어
  - 객체 지향적인 특성을 반영한 쿼리를 날릴 수 있게 도와주는 것


- **commit과 flush 차이점**

  | **항목**   | **commit**                 | **flush**         |
  |----------|----------------------------|-------------------|
  | 특징       | 영속성 컨텍스트에 있는 변경 내용을 DB에 반영 | 변경 내용이 DB에 최종 반영됨 |
  | 롤백 가능 여부 | 트랜잭션이 종료되지 않음→ O           | 트랜잭션이 종료 → X      |
  | 호출 시점    | 수동 호출 가능 및 JPQL 실행 시 자동    | 트랜잭션 종료 시 자동 호출   |


- **QueryDSL, OpenFeign의 QueryDSL**

  - 공식 QueryDSL은 사실상 유지보수 중단상태
  - 기존 QueryDSL 라이브러리의 보안 취약점 및 업데이트 지연 문제 해결을 위해, OpenFeign 진영에서 기존 프로젝트를 포크하여 유지보수하는 버전
    - fork 란?
      - 기존 오픈소스 프로젝트를 복사해서, 내 계정(또는 조직)에서 독립적으로 개발을 이어가는 것



- **N+1 문제 해결할 수 있는 여러 방안들**

  | **해결 방법**          | **설명**                  | **장점**    | **단점**            |
  |--------------------|-------------------------|-----------|-------------------|
  | **Fetch Join**     | 조인으로 한 번에 조회            | 빠름, 간단    | 다중 FetchJoin 시 문제 |
  | **@EntityGraph**   | JPQL 수정 없이 FetchJoin 효과 | 유지보수 쉬움   | 복잡한 관계 불가         |
  | **Batch Size**     | IN 절로 N 줄이기             | 대량 조회 효율적 | 완전 제거 아님          |
  | **DTO Projection** | 필요한 데이터만 한 번에 조회        | 성능 최적화    | 엔티티 기능 불가         |

- **영속 상태의 종류**

    | **상태 이름** | **설명**                  |
    |-----------|-------------------------|
    | **비영속**   | 아직 영속성 컨텍스트에 저장되지 않은 상태 |
    | **영속**    | 영속성 컨텍스트가 관리 중인 상태      |
    | **준영속**   | 한때 영속이었지만 이제 관리되지 않는 상태 |
    | **삭제**    | DB에서 삭제 예정인 상태          |


---


# 학습 후기

- 영속성 컨텍스트에 대해 확실히 짚고 넘어갈 수 있게 되었고 Join과 Join Fetch의 차이점과 N + 1 문제를 확실히 파악할 수 있는 기회가 되었다.